options {	MULTI=false; /* This is because now all of the nodes will be an instance of a derived class of SimpleNode instead of an instance of SimpleNode */	NODE_PREFIX="";	STATIC=false;//Because of multiple files that need to be parsed.}PARSER_BEGIN(SAFParser)package parser;import java.io.*;import java.util.Map;import java.util.HashMap;import java.util.List;import java.util.ArrayList;import saf.*;import saf.astelements.*;import saf.astelements.actions.*;import saf.astelements.conditions.*;import saf.astvisitors.*;import saf.engine.SimpleArenaEngine;import saf.mvc.controllers.SimpleFightController;import saf.mvc.models.SimpleFighterModel;import saf.mvc.views.SimpleFighterArenaView;import saf.mvc.views.twodfighters.figurefactories.PencilDrawnFighterFactory;/* *	TODO:  *		  Nog een keer goed naar de naming kijken en upper lowercase * 		  Support voor brackets bij and en or conditions *		  Alleen getters in AST Node klasses. *		  Als er aan de rechterkant iemand uit beeld gaat! */public class SAFParser {		public static void main(String args[]) throws ParseException {		if(args.length != 2){			System.out.print("Er zijn niet 2 geldige SAF bestanden opgegeven!");		}		else		{			try {				HashMap<String, Fighter> fighters = new HashMap<String, Fighter>();				for(String fighterFile: args){					InputStream inputStream = new FileInputStream(fighterFile);					SAFParser parser = new SAFParser(inputStream);							//Start parsing the file					fighters.put(fighterFile, parser.Fighter());							inputStream.close();					System.out.println("Succesfully parsed file: " + fighterFile + "!");				}				for(String fighterFile: fighters.keySet()){					List<String> errors = Validator.check(fighters.get(fighterFile));					if(!errors.isEmpty()) {						System.out.println("Errors found in " + fighterFile);						for(String error: errors)							System.out.println(error);					}					else {						System.out.println(Printer.printAsString(fighters.get(fighterFile)));						System.out.println();					}				}				ArrayList<Fighter > fighterArrayList = new ArrayList<Fighter>(fighters.values());				startFightSimulation(fighterArrayList.get(0), fighterArrayList.get(1));							} catch (Exception e) {				System.out.println("Exception during parsing: " + e.getMessage());			}		}	}	private static void startFightSimulation(Fighter fighter01, Fighter fighter02)	{	  	System.out.println("Simulation started succesfully.");		try {			SimpleFighterModel fighterModel1 = new SimpleFighterModel(5, 0, 100, "stand", "stand", fighter01);			SimpleFighterModel fighterModel2 = new SimpleFighterModel(10, 0, 100, "stand", "stand", fighter02);				SimpleArenaEngine arenaEngine = new SimpleArenaEngine(fighterModel1, fighterModel2);			PencilDrawnFighterFactory fighterFactory = new PencilDrawnFighterFactory();			SimpleFighterArenaView simpleFightView = new SimpleFighterArenaView(fighterFactory, fighterModel1, fighterModel2);			SimpleFightController fightController = new SimpleFightController(arenaEngine, simpleFightView);			fightController.run();						System.out.println("Simulation ended succesfully.");		} catch (Exception e) {			System.out.println("Exception during simulation: " + e.getMessage() + "\n" + e.getLocalizedMessage());		}	}/* * TODO? *	Class<?> class1; * 	try { *	    class1 = Class.forName(CLASS); *	    Method method = class1.getMethod(METHOD, String.class); *	    Object o = method.invoke(null, NAME); *	    System.out.println(o); *	http://www.wikijava.org/wiki/Class_and_static_Method_Reflection_example * Reflection and virtual functions :) */}PARSER_END(SAFParser)SKIP :{		" "	|	"\t"	| 	"\r"	| 	"\n"}TOKEN: /* AND/OR 's */{		< OR: "or" >	|	< AND: "and" >	|   < CHOOSE: "choose" >}TOKEN : /* IDENTIFIERS */{		< IDENTIFIER: (<LETTER> | "_")+ >	|	< NUMBER: (["1" - "9"])+ >	|	< LETTER: ["a"-"z","A"-"Z"] >}/** Root */Fighter Fighter():{	String name = "";	List<Characteristic> chars = new ArrayList<Characteristic>();	Characteristic characteristic = null;	List<Rule> rules = new ArrayList<Rule>();	Rule rule = null;}{	( name = FighterName())	"{"			( LOOKAHEAD(2)				  	(				  	  	rule = Rule()					  	{					  		rules.add(rule);					  	}				  	)				|	(				  		characteristic = Characteristic()						{							chars.add(characteristic);						}					)			)*	"}"	{		return new Fighter(name, chars, rules);	}}Characteristic Characteristic() :{	String item = "";	Integer value = 0; }{	( item = CharacteristicItem() ) "=" ( value = CharacteristicValue() )	{		return new Characteristic(item, value);	}	  }Rule Rule() :{	ICondition condition = null;	IAction action1 = null;	IAction action2 = null;}{	( condition = ConditionTypes() ) "[" ( action1 = ActionTypes() ) ( action2 = ActionTypes() ) "]" 	{		return new Rule(condition, action1, action2);	}}ICondition ConditionTypes() :{	ICondition condition = null;}{	condition = ORConditionType()	{		return condition;	} }/* * AND has a higher priority than OR http://en.wikipedia.org/wiki/Logical_connective * Therefore AND is lower in the AST.*/ICondition ORConditionType():{	ICondition condition1 = null;	ICondition condition2 = null;}{	condition1 = ANDConditionType() ( LOOKAHEAD(2) < OR > condition2 = ORConditionType())*	{		return ((condition2 == null)? condition1: new ORConnective(condition1, condition2));	}}ICondition ANDConditionType():{	ICondition condition1 = null;	ICondition condition2 = null;}{	condition1 = ConditionType() (LOOKAHEAD(2) < AND > condition2 = ANDConditionType())*	{		return ((condition2 == null)?condition1: new ANDConnective(condition1, condition2));	}}IAction ActionTypes():{	IAction action = null;}{ 	( action = ActionType() )	{		return action;	}| 	( action = ChooseActionType() )	{		return action;	}}IAction ChooseActionType():{	List<IAction> actions = new ArrayList<IAction>();	IAction action = null;}{	< CHOOSE >	"("	(	  	action = ActionTypes()		{			{				actions.add(action);			}		}	)+	")"	{		return new ChooseComposite(actions);	}	  }IAction ActionType():{	Token t;}{ 	t = < IDENTIFIER >	{		return new saf.astelements.actions.Simple(t.image);	}}String FighterName():{	Token t;}{    	t = < IDENTIFIER >	{		return t.image;	}}String CharacteristicItem():{	Token t;}{	t = < IDENTIFIER >	{		return t.image;	}}Integer CharacteristicValue():{	Token t;}{	t = < NUMBER >	{		return Integer.parseInt(t.image);	}}ICondition ConditionType():{	Token t;}{	t = < IDENTIFIER >	{		return new saf.astelements.conditions.Simple(t.image);	}	}