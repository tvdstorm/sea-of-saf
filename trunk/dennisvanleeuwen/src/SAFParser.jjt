options {	MULTI=false; /* This is because now all of the nodes will be an instance of a derived class of SimpleNode instead of an instance of SimpleNode */	NODE_PREFIX="";}PARSER_BEGIN(SAFParser)//package Parser;import java.io.*;import java.awt.List;import ast.*;import ast.conditions.*;import ast.actions.*;import ast.actions.moveActions.*;import ast.actions.fightActions.*;import astChecker.*;import actionCreators.*;public class SAFParser {	public static void main(String args[]) throws ParseException {		try {			InputStream inputStream = new FileInputStream("N:/SoftwareConstruction/SVN/dennisvanleeuwen/src/robots.prgm");			SAFParser parser = new SAFParser(inputStream);			//Start parsing the file			ArenaElement arena = parser.Parse();			inputStream.close();			System.out.println("Succesfully parsed!");			try{				SAFASTElementValidator astChecker = new SAFASTElementValidator();				arena.accept(astChecker);			}			catch(Exception e){				System.out.println("Exception during type checking the AST: " + e.getMessage());			}		} catch (Exception e) {			System.out.println("Exception during parsing: " + e.getMessage());		}	}}PARSER_END(SAFParser)SKIP :{		" "	|	"\t"	| 	"\r"	| 	"\n"}TOKEN: /* AND/OR 's */{		< OR: "or" >	|	< AND: "and" >	|   < CHOOSE: "choose" >}TOKEN : /* IDENTIFIERS */{		< IDENTIFIER: (<LETTER> | "_")+ >	|	< NUMBER: (["1" - "9"])+ >	|	< LETTER: ["a"-"z","A"-"Z"] >}/** Root */ArenaElement Parse():{ArenaElement arena = new ArenaElement(); }{	(Bot(arena))+ <EOF>	{ return arena; }}void Bot(ArenaElement arena):{BotElement bot = new BotElement();}{	BotName(bot) "{" BotProperties(bot) "}"	{ arena.addBot(bot); }}void BotProperties(BotElement bot):{}{	(BotProperty(bot))*}void BotProperty(BotElement bot):{}{  	LOOKAHEAD(2)/* NEEDED because both character and rule start with a identifier!*/		Rule(bot)	|	Characteristic(bot)}void Characteristic(BotElement bot) :{ CharacteristicElement characteristic = new CharacteristicElement(); }{	CharacteristicItem(characteristic) "=" CharacteristicValue(characteristic)	{ bot.addCharacteristic(characteristic); }	  }void Rule(BotElement bot) :{ RuleElement rule = new RuleElement(); }{	ConditionTypes(rule) "[" MoveActionTypes(rule) FightActionTypes(rule) "]" 	{ bot.addRule(rule);}}void ConditionTypes(RuleElement rule) :{ IConditionElement condition = null; }{	condition = ANDConditionType()	{ rule.setCondition(condition); } }IConditionElement ANDConditionType():{ IConditionElement condition1 = null;									   IConditionElement condition2 = null; }{	LOOKAHEAD(2)		condition1 = ORConditionType() < AND > condition2 = ANDConditionType()		{ return new ANDConditionElement(condition1, condition2); }	|  	condition1 = ORConditionType()		{ return condition1; }}IConditionElement ORConditionType():{ IConditionElement condition1 = null;									  IConditionElement condition2 = null; }{	LOOKAHEAD(2)		condition1 = ConditionType() < OR > condition2 = ORConditionType()		{ return new ORConditionElement(condition1, condition2); }	|  	condition1 = ConditionType()		{ return condition1; }}/* * AND has a higher priority than OR http://en.wikipedia.org/wiki/Logical_connective * Therefore AND is lower in the AST.*/void MoveActionTypes(RuleElement rule):{ IActionElement moveAction = null; }{ 		moveAction = MoveActionType()		{ rule.setMoveAction(moveAction); }	| 	moveAction = ChooseMoveActionType()		{ rule.setMoveAction(moveAction); }}void FightActionTypes(RuleElement rule):{ IActionElement fightAction = null; }{ 		fightAction = FightActionType()		{ rule.setFightAction(fightAction); }	| 	fightAction = ChooseFightActionType()		{ rule.setFightAction(fightAction); }}IActionElement ChooseMoveActionType():{ ChooseActionElement chooseAction = new ChooseActionElement(); }{	( < CHOOSE > "(" (PreMoveActionType(chooseAction))+ ")")	{ return chooseAction; }	  }IActionElement ChooseFightActionType():{ ChooseActionElement chooseAction = new ChooseActionElement(); }{	( < CHOOSE > "(" (PreFightActionType(chooseAction))+ ")")	{ return chooseAction; }}void PreMoveActionType(ChooseActionElement chooseAction):{ IActionElement action = null; }{	action = MoveActionType()	{ chooseAction.addAction(action); }}void PreFightActionType(ChooseActionElement chooseAction):{ IActionElement action = null; }{	action = FightActionType()	{ chooseAction.addAction(action); }}IActionElement FightActionType():{ Token t; }{ 	t = < IDENTIFIER >	{ return FightActionElementCreator.getInstance().createAction(t.image); }}IActionElement MoveActionType():{ Token t; }{ 	t = < IDENTIFIER >	{ return MoveActionElementCreator.getInstance().createAction(t.image); }}void BotName(BotElement bot):{ Token t; }{    	t = < IDENTIFIER >	{ bot.setName(t.image); }}void CharacteristicItem(CharacteristicElement characteristic):{ Token t; }{	t = < IDENTIFIER >	{ characteristic.item = t.image; }}void CharacteristicValue(CharacteristicElement characteristic):{ Token t; }{	t = < NUMBER >	{ characteristic.value = Integer.parseInt(t.image); }}IConditionElement ConditionType():{ Token t; }{	t = < IDENTIFIER >	{ return ConditionElementCreator.getInstance().createCondition(t.image); }	}