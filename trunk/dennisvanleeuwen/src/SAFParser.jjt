options {	MULTI=false; /* This is because now all of the nodes will be an instance of a derived class of SimpleNode instead of an instance of SimpleNode */	NODE_PREFIX="";}PARSER_BEGIN(SAFParser)//package Parser;import java.io.*;import astChecker.*;import saf.elementFactories.*;import ast.*;import ast.actions.*;import ast.conditions.*;import ast.actions.fightActions.*;import ast.actions.moveActions.*;public class SAFParser {	private static void initializeFactories() throws Exception{		ConditionElementFactory.getInstance().addElementFactory("always", "ast.conditions.AlwaysConditionElement");		ConditionElementFactory.getInstance().addElementFactory("even", "ast.conditions.EvenConditionElement");		ConditionElementFactory.getInstance().addElementFactory("far", "ast.conditions.FarConditionElement");		ConditionElementFactory.getInstance().addElementFactory("much_stronger", "ast.conditions.MuchStrongerConditionElement");		ConditionElementFactory.getInstance().addElementFactory("much_weaker", "ast.conditions.MuchWeakerConditionElement");		ConditionElementFactory.getInstance().addElementFactory("near", "ast.conditions.NearConditionElement");		ConditionElementFactory.getInstance().addElementFactory("stronger", "ast.conditions.StrongerConditionElement");		ConditionElementFactory.getInstance().addElementFactory("weaker", "ast.conditions.WeakerConditionElement");			MoveActionElementFactory.getInstance().addElementFactory("crouch", "ast.actions.moveActions.CrouchMoveActionElement");		MoveActionElementFactory.getInstance().addElementFactory("jump", "ast.actions.moveActions.JumpMoveActionElement");		MoveActionElementFactory.getInstance().addElementFactory("run_away", "ast.actions.moveActions.RunAwayMoveActionElement");		MoveActionElementFactory.getInstance().addElementFactory("run_towards", "ast.actions.moveActions.RunTowardsMoveActionElement");		MoveActionElementFactory.getInstance().addElementFactory("stand", "ast.actions.moveActions.StandMoveActionElement");		MoveActionElementFactory.getInstance().addElementFactory("walk_away", "ast.actions.moveActions.WalkAwayMoveActionElement");		MoveActionElementFactory.getInstance().addElementFactory("walk_towards", "ast.actions.moveActions.WalkTowardsMoveActionElement");				FightActionElementFactory.getInstance().addElementFactory("punch_low", "ast.actions.fightActions.PunchLowFightActionElement");		FightActionElementFactory.getInstance().addElementFactory("punch_high", "ast.actions.fightActions.PunchHighFightActionElement");		FightActionElementFactory.getInstance().addElementFactory("kick_low", "ast.actions.fightActions.KickLowFightActionElement");		FightActionElementFactory.getInstance().addElementFactory("kick_high", "ast.actions.fightActions.KickHighFightActionElement");		FightActionElementFactory.getInstance().addElementFactory("block_low", "ast.actions.fightActions.BlockLowFightActionElement");		FightActionElementFactory.getInstance().addElementFactory("block_high", "ast.actions.fightActions.BlockHighFightActionElement");	}		public static void main(String args[]) throws ParseException {		try {			initializeFactories();					  			InputStream inputStream = new FileInputStream("N:/SoftwareConstruction/SVN/dennisvanleeuwen/src/robots.prgm");			SAFParser parser = new SAFParser(inputStream);			//Start parsing the file			ArenaElement arena = parser.Parse();			inputStream.close();//			SAFASTElementPrinter astPrinter = new SAFASTElementPrinter();//			arena.accept(astPrinter);				SAFASTElementValidator astChecker = new SAFASTElementValidator();			arena.accept(astChecker);			if(astChecker.hasFoundErrors()){				for(String error: astChecker.getASTErrors())					System.out.println(error);			}			else{				System.out.println("Succesfully parsed!");			}					} catch (Exception e) {			System.out.println("Exception during parsing: " + e.getMessage());		}	}}PARSER_END(SAFParser)SKIP :{		" "	|	"\t"	| 	"\r"	| 	"\n"}TOKEN: /* AND/OR 's */{		< OR: "or" >	|	< AND: "and" >	|   < CHOOSE: "choose" >}TOKEN : /* IDENTIFIERS */{		< IDENTIFIER: (<LETTER> | "_")+ >	|	< NUMBER: (["1" - "9"])+ >	|	< LETTER: ["a"-"z","A"-"Z"] >}/** Root */ArenaElement Parse():{ArenaElement arena = new ArenaElement(); }{	(Bot(arena))+ <EOF>	{ return arena; }}void Bot(ArenaElement arena):{BotElement bot = new BotElement();}{	BotName(bot) "{" BotProperties(bot) "}"	{ arena.addBot(bot); }}void BotProperties(BotElement bot):{}{	(BotProperty(bot))*}void BotProperty(BotElement bot):{}{  	LOOKAHEAD(2)/* NEEDED because both character and rule start with a identifier!*/		Rule(bot)	|	Characteristic(bot)}void Characteristic(BotElement bot) :{ CharacteristicElement characteristic = new CharacteristicElement(); }{	CharacteristicItem(characteristic) "=" CharacteristicValue(characteristic)	{ bot.addCharacteristic(characteristic); }	  }void Rule(BotElement bot) :{ RuleElement rule = new RuleElement(); }{	ConditionTypes(rule) "[" MoveActionTypes(rule) FightActionTypes(rule) "]" 	{ bot.addRule(rule);}}void ConditionTypes(RuleElement rule) :{ IConditionElement condition = null; }{	condition = ANDConditionType()	{ rule.setCondition(condition); } }IConditionElement ANDConditionType():{ IConditionElement condition1 = null;									   IConditionElement condition2 = null; }{	LOOKAHEAD(2)		condition1 = ORConditionType() < AND > condition2 = ANDConditionType()		{ return new ANDConditionElement(condition1, condition2); }	|  	condition1 = ORConditionType()		{ return condition1; }}IConditionElement ORConditionType():{ IConditionElement condition1 = null;									  IConditionElement condition2 = null; }{	LOOKAHEAD(2)		condition1 = ConditionType() < OR > condition2 = ORConditionType()		{ return new ORConditionElement(condition1, condition2); }	|  	condition1 = ConditionType()		{ return condition1; }}/* * AND has a higher priority than OR http://en.wikipedia.org/wiki/Logical_connective * Therefore AND is lower in the AST.*/void MoveActionTypes(RuleElement rule):{ IActionElement moveAction = null; }{ 		moveAction = MoveActionType()		{ rule.setMoveAction(moveAction); }	| 	moveAction = ChooseMoveActionType()		{ rule.setMoveAction(moveAction); }}void FightActionTypes(RuleElement rule):{ IActionElement fightAction = null; }{ 		fightAction = FightActionType()		{ rule.setFightAction(fightAction); }	| 	fightAction = ChooseFightActionType()		{ rule.setFightAction(fightAction); }}IActionElement ChooseMoveActionType():{ ChooseActionElement chooseAction = new ChooseActionElement(); }{	( < CHOOSE > "(" (PreMoveActionType(chooseAction))+ ")")	{ return chooseAction; }	  }IActionElement ChooseFightActionType():{ ChooseActionElement chooseAction = new ChooseActionElement(); }{	( < CHOOSE > "(" (PreFightActionType(chooseAction))+ ")")	{ return chooseAction; }}void PreMoveActionType(ChooseActionElement chooseAction):{ IActionElement action = null; }{	action = MoveActionType()	{ chooseAction.addAction(action); }}void PreFightActionType(ChooseActionElement chooseAction):{ IActionElement action = null; }{	action = FightActionType()	{ chooseAction.addAction(action); }}IActionElement FightActionType():{ Token t; }{ 	t = < IDENTIFIER >	{ return FightActionElementFactory.getInstance().create(t.image); }}IActionElement MoveActionType():{ Token t; }{ 	t = < IDENTIFIER >	{ return MoveActionElementFactory.getInstance().create(t.image); }}void BotName(BotElement bot):{ Token t; }{    	t = < IDENTIFIER >	{ bot.setName(t.image); }}void CharacteristicItem(CharacteristicElement characteristic):{ Token t; }{	t = < IDENTIFIER >	{ characteristic.item = t.image; }}void CharacteristicValue(CharacteristicElement characteristic):{ Token t; }{	t = < NUMBER >	{ characteristic.value = Integer.parseInt(t.image); }}IConditionElement ConditionType():{ Token t; }{	t = < IDENTIFIER >	{ return ConditionElementFactory.getInstance().create(t.image); }	}