options {	MULTI=false; /* This is because now all of the nodes will be an instance of a derived class of SimpleNode instead of an instance of SimpleNode */	NODE_PREFIX="";}PARSER_BEGIN(SAFParser)//package Parser;import java.io.*;import java.util.List;import java.util.ArrayList;import saf.*;import saf.astelements.*;import saf.astelements.actions.*;import saf.astelements.conditions.*;import saf.astvisitors.*;import saf.engine.SimpleArenaEngine;import saf.mvc.controllers.SimpleFightController;import saf.mvc.models.SimpleFighterModel;import saf.mvc.views.FighterArenaView;import saf.mvc.views.twodfighters.figurefactories.PencilDrawnFighterFactory;import java.applet.Applet;import java.awt.*;import java.awt.event.*;import java.awt.font.FontRenderContext;import java.awt.geom.Rectangle2D;import java.awt.image.*;import java.io.*;import java.net.URL;import javax.imageio.ImageIO;import javax.swing.*;import javax.swing.event.*;/* *	TODO:  *		  Nog een keer goed naar de naming kijken en upper lowercase * 		  Support voor brackets bij and en or conditions *		  Misschien de nodes eerst maken en dan met factory method er echt * 		  classes van maken zodat er geen default is! Tenminste geen default tijdens de *		  grafische simulatie, maar alleen als node in de AST *		  Alleen getters in AST Node klasses. *		  Add speed */public class SAFParser {		public static void main(String args[]) throws ParseException {		if(args.length != 1){			System.out.print("Geen geldige SAF file opgegeven!");		}		else		{			try {				initializeFactories();						  				InputStream inputStream = new FileInputStream(args[0]);				SAFParser parser = new SAFParser(inputStream);					//Start parsing the file				Arena arena = parser.Parse();					inputStream.close();					System.out.println(Printer.printAsString(arena));						List<String> errors = Validator.check(arena);								if(!errors.isEmpty()){					for(String error: errors)						System.out.println(error);				}				else{					System.out.println("Succesfully parsed!");				}				startFightSimulation(arena);							} catch (Exception e) {				System.out.println("Exception during parsing: " + e.getMessage());			}		}	}	private static void startFightSimulation(Arena arena)	{	  	System.out.println("Simulation started succesfully.");		try {			SimpleFighterModel fighterModel1 = new SimpleFighterModel(5, 0, 100, "stand", "stand", arena.getFighters().get(0));			SimpleFighterModel fighterModel2 = new SimpleFighterModel(10, 0, 100, "stand", "stand", arena.getFighters().get(1));				SimpleArenaEngine arenaEngine = new SimpleArenaEngine(fighterModel1, fighterModel2);			PencilDrawnFighterFactory fighterFactory = new PencilDrawnFighterFactory();			FighterArenaView simpleFightView = new FighterArenaView(fighterFactory, fighterModel1, fighterModel2);			SimpleFightController fightController = new SimpleFightController(arenaEngine, simpleFightView);			fightController.run();						System.out.println("Simulation ended succesfully.");		} catch (Exception e) {			System.out.println("Exception during simulation: " + e.getMessage() + "\n" + e.getLocalizedMessage());		}	}	private static void initializeFactories() throws Exception{//		ConditionFactory.getInstance().addElementFactory("always", "saf.astelements.conditions.Always");//		ConditionFactory.getInstance().addElementFactory("far", "saf.astelements.conditions.Far");//		ConditionFactory.getInstance().addElementFactory("much_stronger", "saf.astelements.conditions.strength.MuchStronger");//		ConditionFactory.getInstance().addElementFactory("much_weaker", "saf.astelements.conditions.strength.MuchWeaker");//		ConditionFactory.getInstance().addElementFactory("near", "saf.astelements.conditions.Near");//		ConditionFactory.getInstance().addElementFactory("stronger", "saf.astelements.conditions.strength.Stronger");//		ConditionFactory.getInstance().addElementFactory("weaker", "saf.astelements.conditions.strength.Weaker");//	//		MoveActionFactory.getInstance().addElementFactory("crouch", "saf.astelements.actions.move.Crouch");//		MoveActionFactory.getInstance().addElementFactory("jump", "saf.astelements.actions.move.Jump");//		MoveActionFactory.getInstance().addElementFactory("run_away", "saf.astelements.actions.move.RunAway");//		MoveActionFactory.getInstance().addElementFactory("run_towards", "saf.astelements.actions.move.RunTowards");//		MoveActionFactory.getInstance().addElementFactory("stand", "saf.astelements.actions.move.Stand");//		MoveActionFactory.getInstance().addElementFactory("walk_away", "saf.astelements.actions.move.WalkAway");//		MoveActionFactory.getInstance().addElementFactory("walk_towards", "saf.astelements.actions.move.WalkTowards");//		//		FightActionFactory.getInstance().addElementFactory("punch_low", "saf.astelements.actions.fight.PunchLow");//		FightActionFactory.getInstance().addElementFactory("punch_high", "saf.astelements.actions.fight.PunchHigh");//		FightActionFactory.getInstance().addElementFactory("kick_low", "saf.astelements.actions.fight.KickLow");//		FightActionFactory.getInstance().addElementFactory("kick_high", "saf.astelements.actions.fight.KickHigh");//		FightActionFactory.getInstance().addElementFactory("block_low", "saf.astelements.actions.fight.BlockLow");//		FightActionFactory.getInstance().addElementFactory("block_high", "saf.astelements.actions.fight.BlockHigh");/* * TODO? *	Class<?> class1; * 	try { *	    class1 = Class.forName(CLASS); *	    Method method = class1.getMethod(METHOD, String.class); *	    Object o = method.invoke(null, NAME); *	    System.out.println(o); *	http://www.wikijava.org/wiki/Class_and_static_Method_Reflection_example * Reflection and virtual functions :) */	}}PARSER_END(SAFParser)SKIP :{		" "	|	"\t"	| 	"\r"	| 	"\n"}TOKEN: /* AND/OR 's */{		< OR: "or" >	|	< AND: "and" >	|   < CHOOSE: "choose" >}TOKEN : /* IDENTIFIERS */{		< IDENTIFIER: (<LETTER> | "_")+ >	|	< NUMBER: (["1" - "9"])+ >	|	< LETTER: ["a"-"z","A"-"Z"] >}/** Root */Arena Parse():{	List<Fighter> fighters = new ArrayList<Fighter>();	Fighter fighter = null;}{  	(  	  	fighter = Fighter()	  	{			{				fighters.add(fighter);			}		}	)+	<EOF>	{		return new Arena(fighters);	}}Fighter Fighter():{	String name = "";	List<Characteristic> chars = new ArrayList<Characteristic>();	Characteristic characteristic = null;	List<Rule> rules = new ArrayList<Rule>();	Rule rule = null;}{	( name = FighterName())	"{"			( LOOKAHEAD(2)				  	(				  	  	rule = Rule()					  	{					  		rules.add(rule);					  	}				  	)				|	(				  		characteristic = Characteristic()						{							chars.add(characteristic);						}					)			)*	"}"	{		return new Fighter(name, chars, rules);	}}Characteristic Characteristic() :{	String item = "";	Integer value = 0; }{	( item = CharacteristicItem() ) "=" ( value = CharacteristicValue() )	{		return new Characteristic(item, value);	}	  }Rule Rule() :{	ICondition condition = null;	IAction action1 = null;	IAction action2 = null;}{	( condition = ConditionTypes() ) "[" ( action1 = ActionTypes() ) ( action2 = ActionTypes() ) "]" 	{		return new Rule(condition, action1, action2);	}}ICondition ConditionTypes() :{	ICondition condition = null;}{	condition = ORConditionType()	{		return condition;	} }/* * AND has a higher priority than OR http://en.wikipedia.org/wiki/Logical_connective * Therefore AND is lower in the AST.*/ICondition ORConditionType():{	ICondition condition1 = null;	ICondition condition2 = null;}{	condition1 = ANDConditionType() ( LOOKAHEAD(2) < OR > condition2 = ORConditionType())*	{		return ((condition2 == null)? condition1: new ORConnective(condition1, condition2));	}}ICondition ANDConditionType():{	ICondition condition1 = null;	ICondition condition2 = null;}{	condition1 = ConditionType() (LOOKAHEAD(2) < AND > condition2 = ANDConditionType())*	{		return ((condition2 == null)?condition1: new ANDConnective(condition1, condition2));	}}IAction ActionTypes():{	IAction action = null;}{ 	( action = ActionType() )	{		return action;	}| 	( action = ChooseActionType() )	{		return action;	}}IAction ChooseActionType():{	List<IAction> actions = new ArrayList<IAction>();	IAction action = null;}{	< CHOOSE >	"("	(	  	action = ActionTypes()		{			{				actions.add(action);			}		}	)+	")"	{		return new ChooseComposite(actions);	}	  }IAction ActionType():{	Token t;}{ 	t = < IDENTIFIER >	{		return new saf.astelements.actions.Simple(t.image);	}}String FighterName():{	Token t;}{    	t = < IDENTIFIER >	{		return t.image;	}}String CharacteristicItem():{	Token t;}{	t = < IDENTIFIER >	{		return t.image;	}}Integer CharacteristicValue():{	Token t;}{	t = < NUMBER >	{		return Integer.parseInt(t.image);	}}ICondition ConditionType():{	Token t;}{	t = < IDENTIFIER >	{		return new saf.astelements.conditions.Simple(t.image);	}	}