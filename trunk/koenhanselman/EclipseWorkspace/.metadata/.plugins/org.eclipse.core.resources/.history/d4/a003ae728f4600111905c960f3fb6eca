/* This file was generated by SableCC (http://www.sablecc.org/). */

package saf.analysis;

import java.util.*;
import saf.node.*;

public class DepthFirstAdapter extends AnalysisAdapter
{
    public void inStart(Start node)
    {
        defaultIn(node);
    }

    public void outStart(Start node)
    {
        defaultOut(node);
    }

    public void defaultIn(@SuppressWarnings("unused") Node node)
    {
        // Do nothing
    }

    public void defaultOut(@SuppressWarnings("unused") Node node)
    {
        // Do nothing
    }

    @Override
    public void caseStart(Start node)
    {
        inStart(node);
        node.getPProgram().apply(this);
        node.getEOF().apply(this);
        outStart(node);
    }

    public void inAProgram(AProgram node)
    {
        defaultIn(node);
    }

    public void outAProgram(AProgram node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAProgram(AProgram node)
    {
        inAProgram(node);
        if(node.getProgramHeader() != null)
        {
            node.getProgramHeader().apply(this);
        }
        if(node.getProgramPersonality() != null)
        {
            node.getProgramPersonality().apply(this);
        }
        if(node.getProgramBehaviour() != null)
        {
            node.getProgramBehaviour().apply(this);
        }
        if(node.getProgramFooter() != null)
        {
            node.getProgramFooter().apply(this);
        }
        outAProgram(node);
    }

    public void inAProgramHeader(AProgramHeader node)
    {
        defaultIn(node);
    }

    public void outAProgramHeader(AProgramHeader node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAProgramHeader(AProgramHeader node)
    {
        inAProgramHeader(node);
        {
            List<TLetter> copy = new ArrayList<TLetter>(node.getLetter());
            for(TLetter e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getLeftCurly() != null)
        {
            node.getLeftCurly().apply(this);
        }
        outAProgramHeader(node);
    }

    public void inAProgramFooter(AProgramFooter node)
    {
        defaultIn(node);
    }

    public void outAProgramFooter(AProgramFooter node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAProgramFooter(AProgramFooter node)
    {
        inAProgramFooter(node);
        if(node.getRightCurly() != null)
        {
            node.getRightCurly().apply(this);
        }
        outAProgramFooter(node);
    }

    public void inAProgramPersonality(AProgramPersonality node)
    {
        defaultIn(node);
    }

    public void outAProgramPersonality(AProgramPersonality node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAProgramPersonality(AProgramPersonality node)
    {
        inAProgramPersonality(node);
        {
            List<PProgramCharacteristic> copy = new ArrayList<PProgramCharacteristic>(node.getProgramCharacteristic());
            for(PProgramCharacteristic e : copy)
            {
                e.apply(this);
            }
        }
        outAProgramPersonality(node);
    }

    public void inAProgramCharacteristic(AProgramCharacteristic node)
    {
        defaultIn(node);
    }

    public void outAProgramCharacteristic(AProgramCharacteristic node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAProgramCharacteristic(AProgramCharacteristic node)
    {
        inAProgramCharacteristic(node);
        {
            List<TLetter> copy = new ArrayList<TLetter>(node.getLetter());
            for(TLetter e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getEquals() != null)
        {
            node.getEquals().apply(this);
        }
        if(node.getDigit() != null)
        {
            node.getDigit().apply(this);
        }
        outAProgramCharacteristic(node);
    }

    public void inAProgramBehaviour(AProgramBehaviour node)
    {
        defaultIn(node);
    }

    public void outAProgramBehaviour(AProgramBehaviour node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAProgramBehaviour(AProgramBehaviour node)
    {
        inAProgramBehaviour(node);
        {
            List<PProgramRule> copy = new ArrayList<PProgramRule>(node.getProgramRule());
            for(PProgramRule e : copy)
            {
                e.apply(this);
            }
        }
        outAProgramBehaviour(node);
    }

    public void inAProgramRule(AProgramRule node)
    {
        defaultIn(node);
    }

    public void outAProgramRule(AProgramRule node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAProgramRule(AProgramRule node)
    {
        inAProgramRule(node);
        {
            List<TLetter> copy = new ArrayList<TLetter>(node.getLetter());
            for(TLetter e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getLeftBracket() != null)
        {
            node.getLeftBracket().apply(this);
        }
        if(node.getFight() != null)
        {
            node.getFight().apply(this);
        }
        if(node.getMove() != null)
        {
            node.getMove().apply(this);
        }
        if(node.getRightBracket() != null)
        {
            node.getRightBracket().apply(this);
        }
        outAProgramRule(node);
    }

    public void inAChooseActionProgramAction(AChooseActionProgramAction node)
    {
        defaultIn(node);
    }

    public void outAChooseActionProgramAction(AChooseActionProgramAction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAChooseActionProgramAction(AChooseActionProgramAction node)
    {
        inAChooseActionProgramAction(node);
        {
            List<TLetter> copy = new ArrayList<TLetter>(node.getChoose());
            for(TLetter e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getLeftParen() != null)
        {
            node.getLeftParen().apply(this);
        }
        {
            List<TLetter> copy = new ArrayList<TLetter>(node.getActions());
            for(TLetter e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getRightParen() != null)
        {
            node.getRightParen().apply(this);
        }
        outAChooseActionProgramAction(node);
    }

    public void inASingleActionProgramAction(ASingleActionProgramAction node)
    {
        defaultIn(node);
    }

    public void outASingleActionProgramAction(ASingleActionProgramAction node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASingleActionProgramAction(ASingleActionProgramAction node)
    {
        inASingleActionProgramAction(node);
        {
            List<TLetter> copy = new ArrayList<TLetter>(node.getAction());
            for(TLetter e : copy)
            {
                e.apply(this);
            }
        }
        outASingleActionProgramAction(node);
    }
}
