options{	JDK_VERSION = "1.5";	static = false;	LOOKAHEAD = 10;}PARSER_BEGIN(Parser)package saf.parser;import saf.ast.*;import saf.ast.condition.*;import saf.ast.definition.*;import java.util.*;import java.io.FileNotFoundException;public class Parser {	private Fighter fighter;	public Fighter getFighter() { 		return fighter;	}	public Parser(String fileName) throws FileNotFoundException {		this(new java.io.FileInputStream(new java.io.File(fileName)));	}	public static void main(String args []) { 	    System.out.println("Reading from standard input...");	    System.out.print("Enter a SAF specification: ");	    		Parser parser = new Parser(System.in);	    try	    {	      parser.Root();	    }	    catch (Exception e)	    {	      System.out.println("Oops.");	      System.out.println(e);		}	}}PARSER_END(Parser)SKIP :{  " "| "\t"| "\n"| "\r"}TOKEN :{ 	< CONNECTIVE : "and" | "or" >}TOKEN :{  < INTEGER_LITERAL : (["0"-"9"])+ >}TOKEN :{  < IDENTIFIER :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < #LETTER : [ "_", "a"-"z", "A"-"Z" ] >| < #DIGIT : [ "0"-"9" ] >}void Root() :{	Token fighterName;}{	fighterName = < IDENTIFIER > "{"	{		fighter = new Fighter(fighterName.image);	}		(AssignmentStatement())*		(BehaviourStatement())*	"}"}void AssignmentStatement() :{	Token identifier;	Token integerLiteral;}{  	identifier = < IDENTIFIER >  	"="  	integerLiteral = < INTEGER_LITERAL >	{		Strength assignment = new Strength(identifier.image, Integer.parseInt(integerLiteral.image));		fighter.getDefinitions().add(assignment);	}}void BehaviourStatement() :{  	Token identifier;  	Condition expression;  	Procedure move;  	Procedure attack;}{  	expression = LogicalExpr()  	"["  		move = FunctionCall()  		attack = FunctionCall()  	"]"  	{		Behaviour behaviour = new Behaviour(expression, move, attack);		fighter.getDefinitions().add(behaviour);  	}}Condition LogicalExpr() :{	Condition leftExpr;	Condition rightExpr;	Token identifier;	Token identifier2;	Token connective;}{  	// ( expr ) c expr	"("	leftExpr	= LogicalExpr()	")"	connective	= < CONNECTIVE >	rightExpr	= LogicalExpr()	{		if (connective.image.equals("or"))		{			return new OrOperator(leftExpr, rightExpr);		}	  	else if (connective.image.equals("and"))	  	{			return new AndOperator(leftExpr, rightExpr);	  	}	}	|	// ( expr )  	"("  	leftExpr	= LogicalExpr()  	")"  	{		return leftExpr;  	} 	| 	// i c expr	identifier	= < IDENTIFIER >	connective	= < CONNECTIVE >	rightExpr	= LogicalExpr()  	{  	  	if (connective.image.equals("and"))  	  	{	  	  	Condition state = new Condition(identifier.image);			if (rightExpr instanceof LogicalCondition)			{			  	// do some "transformation"			  	AndOperator and = new AndOperator(state, ((LogicalCondition)rightExpr).getLeftExpression());			  	((LogicalCondition)rightExpr).setLeftExpression(and);			  	return rightExpr;			}			else			{				return new AndOperator(state, rightExpr);			}		} 	  	else if (connective.image.equals("or")) 	  	{  	  		Condition state = new Condition(identifier.image);			return new OrOperator(state, rightExpr);		}  	}	|   	identifier	= < IDENTIFIER >  	{		return new Condition(identifier.image);  	}}Procedure FunctionCall() :{  	Token identifier;  	Procedure param;}{  	identifier = < IDENTIFIER >  	{		Procedure procedure;		if (identifier.image.equals("choose"))		{			procedure = new Choose();		}		else		{		  	procedure = new Action(identifier.image);		}  	}  	"("  	(  	  	param = FunctionCall()  	  	{  		  	procedure.getProcedures().add(param);  		}  	)+  	")"  	{		return procedure;  	}  	| 	identifier = < IDENTIFIER >  	{  	  	Procedure procedure;  	  	if (identifier.image.equals("choose"))  	  	{			procedure = new Choose();  	  	}  	  	else  	  	{			procedure = new Action(identifier.image);		}		return procedure;  	}}